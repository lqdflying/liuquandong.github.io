<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第三章 启动和关闭AIX操作系统</title>
    <link href="/2020/11/26/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%ADAIX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/11/26/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%ADAIX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="一、小机启动时，可以再引导过程中，选择不同的系统运行模式："><a href="#一、小机启动时，可以再引导过程中，选择不同的系统运行模式：" class="headerlink" title="一、小机启动时，可以再引导过程中，选择不同的系统运行模式："></a>一、小机启动时，可以再引导过程中，选择不同的系统运行模式：</h4><ol><li>从 磁带或者cdrom引导系统进入维护模式（单用户模式）</li><li>从硬盘引导系统进入到维护模式（单用户模式）和正常模式（多用户模式）</li><li>进入系统管理维护模式（SMS模式：System Management Services）</li></ol><h4 id="二、一般引导过程概述"><a href="#二、一般引导过程概述" class="headerlink" title="二、一般引导过程概述"></a>二、一般引导过程概述</h4><p> 经典的RS6000机器（MCA）结构系统硬件自检分两个阶段：内置设备自检阶段（BIST）和加电自检阶段（POST），对于PCI的机器，则由单独的加电自检（POST）完成硬件检查。<br>经过硬件检查，系统就尝试加载引导逻辑卷（BLV：Boot Logical Volume），并在内存中形成RAMFS，并把控制权交给BLV，但由于内存中没有加载任何LVM（logic volume manager，LVM）的驱动，因此系统必须在不适用LVM的情况下正确找到BLV数据在硬盘上的位置。正确的BLV的地址信息（包括偏移量和长度）保存在引导磁盘的第一个物理扇区（这个扇区有512字节的块）上，这个扇区称之为引导记录（Boot Record）。</p><blockquote><p><strong>RAM文件系统</strong><br>        RAMFS是引导镜像的一部分，完全常驻内存，而且包含很多能让引导继续的程序。在RAM文件系统中运行的init进程实际上是ssh（simple shell）程序，这个程序通过调用rc.boot脚本来控制系统引导过程，rc.boot脚本第一步决定操作系统从哪个设备上引导，决定引导的设备应该在RAM文件系统中的配置（rc.boot脚本找到引导设备以后，从RAM文件系统中条用相应的程序来进行配置）</p></blockquote><p>引导逻辑卷BLV也成为引导镜像，它包括下边这几个部分：</p><ol><li>软件ROS——ROS是“只读存储器”的意思，软件ROS只存在于PCI的机器中，执行一些系统初始化的工作，PCI机器的ROS不提供软件ROS，而由AIX提供</li><li>AIX内核——AIX内核总是从BLV加载。/unix(软连接到/usr/lib/boot/unix_mp或unix_up)是一份内核副本，这个版本被用于构建hd4文件系统（也就是根文件系统）。在系统引导时，从hd4文件系统读取内核镜像。</li><li>rc.boot——rc.boot是一个shell命令文件，它是配置系统的脚本，在系统引导期间，init进程要执行这个脚本三次：</li></ol><blockquote><p>当加载BLV以后，由于rootvg没有被激活，并不可用，引导所需的信息都包含在用于在内存中创建RAM文件系统的BLV中，之后，init进程被加载运行，并由init进程开始配置基本信息：这就是第一引导阶段，这个阶段，init执行rc.boot的时候，带个参数1。<br> 下一步为第二引导阶段（init执行rc.boot的时候，带个参数2），主要目的是激活rootvg（也是最容易出现问题的阶段，比如文件系统或者是jsflog损坏），接着把控制权交给rootvg中的init进程，然后释放RAM文件系统。<br> 第三引导阶段，init进程（从磁盘加载的init进程，而不是BLV中的init进程）带参数3执行rc.boot脚本配置剩余的设备，并从/etc/inittab启动其他进程</p></blockquote><ol start="4"><li>简化的ODM——只提供最基本的设备配置信息</li><li>引导命令——比如cfgmgr和bootinfo等</li></ol><h4 id="三、基于PCI的系统引导模式"><a href="#三、基于PCI的系统引导模式" class="headerlink" title="三、基于PCI的系统引导模式"></a>三、基于PCI的系统引导模式</h4><p>基于PCI的只有两种引导模式，分别是normal模式和service模式，多用户模式一般从内置硬盘启动，单用户模式可以从磁盘，cdrom或者硬盘启动。<br> 以维护模式引导系统，就会进入到系统诊断状态，用户可以查看和更改系统的设备和配置，可以进行系统的诊断和维护工作。此时系统中只有一个root用户，所以称之为单用户模式。PCI系统的维护模式分为两种，一种：独立诊断模式（从磁带或者是cdrom引导到维护模式）。另一种是在线诊断模式（从硬盘引导）<br> 在POST时确定引导模式，系统根据引导设备列表来引导，比如：“软磁盘-cdrom-硬盘-网络设备”类似这样一个设备组成。用户可以自己修改引导设备列表（用bootlist命令）也可以用SMS来自定义引导设备列表。自定义引导设备列表保存在NVRAM中，默认的引导列表保存在ROS中。<br> 启动POST完成时，在第一个图标出来之后和最后一个图标出来之前，按键盘某个按键，进入相应模式：</p><ul><li> F1/1    —-&gt;SMS系统管理维护模式</li><li> F5/5    —-&gt;默认引导设备列表引导维护模式，进入独立诊断模式</li><li> F6/6    —-&gt;自定义引导设备列表引导维护模式，进入在线诊断模式</li><li> F8/8    —-&gt;正常模式引导</li></ul><p>在支持AIX的操作系统的机器是上，无论是否已安装AIX，都可以进入到独立诊断模式，只有安装了系统的机器可以进入在线诊断模式，诊断模式类型由系统从什么介质启动决定。<br> 通过磁带、cdrom和网络方式启动系统，rootvg卷组不会激活，因为root卷组可能不存在（重新安装系统）。一旦进入独立诊断模式，就不能取出光盘，只能在给机器加电之后和POST完成之前才能去除光盘。</p><h4 id="四、多用户模式启动流程"><a href="#四、多用户模式启动流程" class="headerlink" title="四、多用户模式启动流程"></a>四、多用户模式启动流程</h4><h5 id="1-ROS内核初始化阶段"><a href="#1-ROS内核初始化阶段" class="headerlink" title="1. ROS内核初始化阶段"></a>1. ROS内核初始化阶段</h5><ol><li>首先由OCS（On-chip Sequencer）调用微处理器检查系统主板是否有问题，然后将控制权交给只读存储器（ROS），并执行系统加电自检（POST）</li><li>ROS初始化载入程序（IPL）检查用户自定义引导设备列表（Boot List），如果找不到自定义列表或者自定义引导设备列表不正确，就会使用默认引导列表，然后使用在引导列表中找到的第一个设备来引导。</li><li>到找到第一个可以引导的设备后，就检测引导设备上的第一个记录或物理扇区号（PSN：physical sector number）。如果是合法的引导记录。则把它读入内存，并附加到初始装入程序（IPL）的控制块上。然后根据引导记录中包含的“引导逻辑卷（BLV）长度和BLV的地址（BLV）在引导设备上的位置”把BLV装入到内存。</li><li>从引导设备中顺序的把引导逻辑卷（也就是引导镜像）读入到内存，建立RAM文件系统（RAMFS）。引导逻辑卷（BLV）由“内核、一个RAM文件系统和基本初始化设备信息（简化的ODM）组成。”</li><li>把控制权移交给在RAM文件系统中开始系统初始化的内核。</li><li>系统初始化的内核运行init程序（进程号为1），init进程继续去执行rc.boot脚本，并附带参数1</li><li>内核初始化阶段和硬件检测阶段结束。</li></ol><h5 id="2-基本设备配置阶段-rc-boot第1阶段"><a href="#2-基本设备配置阶段-rc-boot第1阶段" class="headerlink" title="2. 基本设备配置阶段(rc.boot第1阶段)"></a>2. 基本设备配置阶段(rc.boot第1阶段)</h5><p>现在的情况是，系统完成硬件检测，找到BLV，简历了RAM，启动了RAM中的init进程，但是rootvg还没有激活。rc.boot第一阶段主要是完成基本的设备配置</p><ol><li>RAMFS中的init进程执行引导脚本rc.boot带参数1，在这个过程中，rc.boot调用restbase命令，把引导逻辑卷（BLV）上的简化ODM数据库复制到RAMFS，如果这个操作时被，LED面板显示548.</li><li>然后rc.boot执行cfgmgr -f命令（配置管理器），让cfgmgr从简化的ODM数据库中读取Config_Rules类，在Config_Rules类中，属性值为1的设备都被认为是基本设备，基本设备是为访问rootvg所需的全部设备。rc.boot这个阶段执行cfgmgr来配置基本设备，以便在下一个rc.boot阶段能够激活rootvg。<br>以下就是这个文件的位置<br><img src="https://cdn.jsdelivr.net/gh/lqdflying/img@img/img/1.jpg" alt="1"><br>顺便可以查出这个类下边phrase=1的对象：<br><img src="https://cdn.jsdelivr.net/gh/lqdflying/img@img/img/9a63578241fc436dba893254ef705062.jpg" alt="9a63578241fc436dba893254ef705062"><br>（后边还有，未截图列出）</li><li> 在rc.boot第一个引导阶段的最后，执行bootinfo -b命令来检测最后一次引导设备，这时LED显示511.</li></ol><h5 id="3-rc-boot第2引导阶段"><a href="#3-rc-boot第2引导阶段" class="headerlink" title="3. rc.boot第2引导阶段"></a>3. rc.boot第2引导阶段</h5><ol><li>rc.boot执行ipl_varyon命令激活rootvg，若这个命令和执行不成功，则显示522、554、556中的一个</li><li>ipl_varyon执行成功以后，用fsck -fp /dev/hd4命令检查rootvg（位于磁盘上）的根文件系统，然后把rootvg的根文件系统（/dev/hd4）安装在RAMFS的临时安装点上（/mnt），这一步失败，显示错误代码555、557</li><li>安装/var和/usr文件系统。如果失败，显示518.一旦安装了/var文啊进系统，就用copycore命令把默认的dump设备(/dev/hd6)里最后的dump复制到默认的副本目录(/var/adm/ras)，复制完dump之后，就卸载/var文件系统。</li><li>运行swapon(/usr/sbin/swapon)命令来激活rootvg上基本的页面空间(/dev/hd6)</li><li>用mergedev命令把RAMFS中/dev目录复制到磁盘上的文件系统中，再用cp Cu* /mnt/etc/bojrepos命令吧RAMFS中用户化的ODM数据库复制到磁盘上，这里/mnt/etc/bojrepos这个路径是因为，根目录/本临时挂在到RAMFS中的/mnt这个安装点上</li><li>从RAMFS中卸载/var和rootvg的根文件系统/dev/hd4（挂在到/mnt）</li><li>在RAMFS的根文件系统所在的安装点上永久性安装rootvg（位于磁盘）的根文件系统，由newroot命令完成RAM文件系统到rootvg的文件系统的切换。root卷组中的文件系统安装点可以使用以后，就将root卷组中的/usr和/var文件系统安装到相应的安装点</li><li>此时没有可使用的控制台，所有的引导信息都被复制到错误日志alog中</li><li>退出执行rc.boot脚本，把控制权移交给root卷组中的init进程，然后释放RAM文件系统</li><li>位于硬盘上的init进程将执行整个启动过程的最后一部分</li></ol><blockquote><p><strong>因为控制台不可用，所以输出信息都记录在alog中</strong></p></blockquote><ul><li>init程序读取/etc/inittab文件，如果/etc/inittab存在，则init程序在/etc/inittab中寻找默认的系统启动初始记录（记录标识符是init，第三个字段是initdefault），整个记录中包含了预先登记在文件/etc/inittab中的进程。初始记录不存在，则init进程就会要求用户从系统控制台（/dev/console）输入一个运行级别。（用户输入S、s、M、m则进入单用户模式，只有进入单用户模式才不要求/etc/inittab内容必须是完整的）</li><li>如果/etc/inittab不存在，init默认直接进入系统维护运行级别</li><li>init进程每隔60秒重新读取一次/etc/inittab文件，如果init进程上次读过该文件之后，新增删了东西，这一次读取也会执行这些变化。</li></ul><h5 id="4-rc-boot第3引导阶段"><a href="#4-rc-boot第3引导阶段" class="headerlink" title="4. rc.boot第3引导阶段"></a>4. rc.boot第3引导阶段</h5><p>在/etc/inittab文件中第一条记录为initdefault，第二条记录的标识符为brc，这条记录就是指示init去执行rc.boot第3阶段。<br><img src="https://cdn.jsdelivr.net/gh/lqdflying/img@img/img/4574c68d17e0425aa9757973a54a695e.jpg" alt="4574c68d17e0425aa9757973a54a695e"><br>第3阶段工作为：</p><ol><li>安装/tmp文件系统</li><li>同步rootvg（通过执行命令#syncvg -v rootvg &amp;），这可能会花一些时间，如果执行失败，则显示错误代码553</li><li>如果是正常（normal）引导，则执行cfgmgr -p2命令；如果是维护（service）模式引导，则执行cfgmgr -p3命令。cfgmgr读取ODM数据库中的Config_rules类，检查属性值是2或者是3的设备，并对其进行配置（属性值为1的设备在第1阶段就检查完了），即配置所有剩余设备。</li><li>用cfgcon命令配置控制台。不同的终端设备，在LED上显示的代码不同。</li><li>执行savebase命令把/（根）文件系统中的ODM数据库保存引导逻辑卷（BLV）中</li><li>退出执行rc.boot脚本，然后由init进程顺序启动/etc/inittab文件中的其他进程</li></ol><h4 id="五、操作系统运行级别"><a href="#五、操作系统运行级别" class="headerlink" title="五、操作系统运行级别"></a>五、操作系统运行级别</h4><p>操作系统真正的运行级别有11个，是0-9，再加一个S、s、M、m，其中级别2表示多用户模式，S、s、M、m这写个级别表示单用户模式（维护模式）</p><h4 id="六、init进程重读-etc-inittab文件"><a href="#六、init进程重读-etc-inittab文件" class="headerlink" title="六、init进程重读/etc/inittab文件"></a>六、init进程重读/etc/inittab文件</h4><pre><code>    不论进程犹豫什么原因停止，init进程都会收到这个进程停止运行的信号，并且在/etc/utmp中记录它结束运行的原因，同时还会在文件/var/adm/wtmp中保存进程启动的历史记录。    当用户编辑了/etc/inittab文件，增加了一条记录或者修改了其中的command字段，init进程不会马上重读该文件，所增加或者是修改的进程不会被立刻创建，除非以下3个条件之一发生，新进程才能被创建——</code></pre><ol><li>init进程的子孙进程中有一个进程结束了</li><li>出现电源失败信号SIGPWR</li><li>用户用init命令发出改变系统运行级别和重新检查/etc/inittab文件的信号<br>其中，以上三个条件最简单的方法就是用init命令发出重新检查/etc/inittab文件的信号<pre class="language-bash" data-language="bash"><code class="language-bash">#init Q#telinit -q</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>AIX 5L系统管理技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 安装AIX操作系统</title>
    <link href="/2020/11/25/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AE%89%E8%A3%85AIX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/11/25/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AE%89%E8%A3%85AIX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="安装AIX操作系统"><a href="#安装AIX操作系统" class="headerlink" title="安装AIX操作系统"></a>安装AIX操作系统</h4><p>开始安装<br><img src="https://cdn.jsdelivr.net/gh/lqdflying/img@img/img/20201125173326.jpg"></p><ul><li>使用默认设置立即开始安装操作系统* </li><li>改变安装设置并进行安装</li><li>在维护模式下进行系统恢复<br><img src="https://cdn.jsdelivr.net/gh/lqdflying/img@img/img/20201125173328.jpg"></li><li>直接使用上边的设置来安装</li><li>改变系统设置(覆盖安装、保留安装,迁移安装)</li><li>选择环境参数</li><li>包含选择安装内容,信任计算基础(TCB),桌面环境,64位内核和JFS2的选择<br>选择1以后显示下图——<br><img src="https://cdn.jsdelivr.net/gh/lqdflying/img@img/img/20201125173327.jpg"></li><li>全新覆盖安装<ol><li>机器是新的,无任何BOS时,选择此项</li><li>机器上安装了操作系统,但是由于某种原因,系统被破坏了,需要重新覆盖原有操作系统</li><li>当需要重新分配硬盘时,由于rootvg也占用了硬盘,因此需要重新安装操作系统,rootvg会被重写覆盖,此时需要用覆盖安装</li></ol></li><li>保留安装<ol><li>当安装了旧版本的操作系统,需要更新到新的版本,但同时还要保留rootvg上的用户数据的时候,就采用这个安装方式</li><li>默认会删除/(root),/usr,/var,/tmp这些文件系统的内容,而保留page和dump两个设备,也保留/home及用户创建的文件系统</li><li>安装过程中,列在文件/etc/preserve.list上的上的文件系统会被复制和保留起来,默认情况下只包括/etc/filesystems,/etc/swapspaces,/etc/resolv.conf等着三个文件。</li><li>修改后的/etc/preserve.list通过以下命令保存到软盘上<pre class="language-bash" data-language="bash"><code class="language-bash">#cd &#x2F;etc#ls .&#x2F;preserve.list | backup -iqv</code></pre></li><li>系统安装时,默认的搜索/etc/preserve.list文件的顺序是:软盘—-安装系统的机器上—-安装介质上的/etc/preserve.list文件</li></ol></li><li>迁移安装<br>为了保留已经存在root卷组上的内容,而且要将AIX 3.2/4.2/4.3升级到5L,就可以采用迁移安装的方式,这种方式除了不保留tmp文件系统,将保留其他所有文件系统,包括root卷组,逻辑卷和系统配置文件等<br><img src="https://cdn.jsdelivr.net/gh/lqdflying/img@img/img/20201125173329.jpg"><br>手动启动命令符安装助手命令:<br><code>#install_assist</code><ol><li>设定时间日期</li><li>设置root密码</li><li>变更或确认用来安装其他软件的设备(cdrom或者磁带机或者本地/远程等)</li><li>管理系统存储空间和页面空间</li><li>配置网络通信</li><li>变更基本语言环境或新增加其他语言环境</li><li>创建用户</li><li>配置打印机</li><li>导入任何已存在的卷组</li><li>安装其他软件和应用程序</li><li>备份系统</li><li>退出“安装助手程序”并登陆系统<br>维护包(ML)的命名规则:VRMF——</li></ol></li><li>V:操作系统版本号Version</li><li>R:发行版本号Release</li><li>M:修正版本号Modification</li><li>F:修订版本号Fix<br>推荐维护包命名规则:VRMF-RM——</li><li>V:操作系统版本号Version</li><li>R:发行版本号Release</li><li>M:修正版本号Modification</li><li>F:修订版本号Fix</li><li>RM:推荐维护包Recommended Maintenance</li></ul>]]></content>
    
    
    <categories>
      
      <category>AIX 5L系统管理技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 AIX操作系统概述</title>
    <link href="/2020/11/25/%E7%AC%AC%E4%B8%80%E7%AB%A0-AIX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/11/25/%E7%AC%AC%E4%B8%80%E7%AB%A0-AIX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="一、AIX操作系统提供了其他UNIX系统没有的功能"><a href="#一、AIX操作系统提供了其他UNIX系统没有的功能" class="headerlink" title="一、AIX操作系统提供了其他UNIX系统没有的功能:"></a>一、AIX操作系统提供了其他UNIX系统没有的功能:</h4><ul><li>逻辑卷管理器(logic volume manager,LVM)</li><li>系统管理接口工具(system management interface tool,SMIT)</li><li>信任计算基础(TCB)</li><li>网络文件系统(NFS)</li></ul><h4 id="二、AIX-version4特点"><a href="#二、AIX-version4特点" class="headerlink" title="二、AIX version4特点:"></a>二、AIX version4特点:</h4><ul><li>网络安装管理器(network install manager,NIM)</li><li>日志型文件系统(JFS)</li><li>动态主机配置协议(DHCP)</li><li>通用桌面环境(CDE)</li><li>支持对称多处理系统(SMP)</li><li>基于web的系统管理器</li><li>工作负载管理器(WLM)</li><li>IPV6</li><li>在线文档库</li><li>64位计算<h4 id="三、AIX-5L中的改进"><a href="#三、AIX-5L中的改进" class="headerlink" title="三、AIX 5L中的改进"></a>三、AIX 5L中的改进</h4></li><li>JFS2</li><li>NFS中的statd进程多线程优化</li><li>被动镜像写一致性</li><li>配置管理器(configuration manager,cfgmgr)</li><li>基于web的管理系统</li><li>工作负载管理器(WLM)<h4 id="四、AIX-5L中的新功能"><a href="#四、AIX-5L中的新功能" class="headerlink" title="四、AIX 5L中的新功能"></a>四、AIX 5L中的新功能</h4></li><li>/proc文件系统</li><li>/opt文件系统</li><li>停用活动的页面空间</li><li>资源监视控制器(RMC)</li><li>支持虚拟IP地址</li><li>动态逻辑分区(DLPAR):5.1是Lpar,5.2+是DLpar</li></ul><h4 id="五、AIX内核特点"><a href="#五、AIX内核特点" class="headerlink" title="五、AIX内核特点:"></a>五、AIX内核特点:</h4><p><code>抢占式,可置换,动态性,可扩展性</code></p><h4 id="六、应用程序-内核和硬件之间在32位VS-64位的关系组合"><a href="#六、应用程序-内核和硬件之间在32位VS-64位的关系组合" class="headerlink" title="六、应用程序,内核和硬件之间在32位VS.64位的关系组合"></a>六、应用程序,内核和硬件之间在32位VS.64位的关系组合</h4><ul><li>要运行64位内核,需要有64位的硬件环境</li><li>加载了64位的内核扩展并不能说明系统的内核是64位的,AIX只有从5.1L开始才有64位的内核,64位的内核扩展仅仅是允许在32位的内核中编译64位的应用,如果32位内核具有64位的硬件环境(处理器),则syscalls64.ext文件集将允许运行64位的应用,但是在AIX5.1中,64位内核配合64位处理器将使64位的应用具有更好的性能</li><li>大多数情况下,在64位的硬件结构中运行32位的应用是没有问题的,因为64位的硬件兼容64和32位的软件,但是32位硬件上不可以运行64位的软件</li><li>AIX3.3.3上的32位应用可以直接运行在AIX5.1上,但是AIX3.3.3上的64位应用必须在AIX5.1上重新编译才可以使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>AIX 5L系统管理技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aix</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
